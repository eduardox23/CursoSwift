////  PlayScene.swift//  Seaquest////  Created by Marcio Barros on 11/26/14.//  Copyright (c) 2014 UNIRIO. All rights reserved.//import SpriteKitimport AVFoundationstruct PhysicsCategory {    static let None      : UInt32 = 0    static let Submarine : UInt32 = 0b001    static let Diver     : UInt32 = 0b010    static let Shark     : UInt32 = 0b100}class PlayScene: SKScene, SKPhysicsContactDelegate {	var azymuth = SKSpriteNode(imageNamed: "azymuth")	var seaFloor = SKSpriteNode(imageNamed: "seafloor")    var submarine = SKSpriteNode(imageNamed: "submarine")	var navigationArea : CGRect!    var oxygen = 100.0    var oxygenUsed : SKShapeNode!    var sharks : [SKSpriteNode] = []	var divers : [SKSpriteNode] = []	var lifeNodes : [SKSpriteNode] = []    var remainingLifes = 3    var scoreNode = SKLabelNode()    var score = 0	var gamePaused = false		/*	 * Prepares the elements handled in the scene	 */    override func didMoveToView(view: SKView) {		setupPhysicsWorld()		createBackground()		createOxygenBar()		createSubmarine()		createSharksAndDivers()		createStatusBar()    }		/*	 * Setup the characteristics of the physics world used in the scene	 */	func setupPhysicsWorld() {		physicsWorld.gravity = CGVectorMake(0, 0)		physicsWorld.contactDelegate = self	}	/*	 * Creates the scene background and computes the navigation area	 */	func createBackground() {		backgroundColor = UIColor(hex: 0x0000FF)			azymuth.anchorPoint = CGPointMake(0.0, 1.0)		azymuth.position = CGPointMake(frame.minX, frame.maxY - 40)		addChild(azymuth)				seaFloor.anchorPoint = CGPointMake(0.0, 1.0)		seaFloor.position = CGPointMake(frame.minX, frame.minY + seaFloor.size.height + 30)		addChild(seaFloor)			let minNavigationY = frame.minY + seaFloor.size.height + 40 + submarine.size.height / 2		let maxNavigationY = frame.maxY - azymuth.size.height - 50 + submarine.size.height / 2		let minNavigationX = frame.minX + 10 + submarine.size.width / 2		let maxNavigationX = frame.maxX - 10 - submarine.size.width / 2		navigationArea = CGRectMake(minNavigationX, minNavigationY, maxNavigationX - minNavigationX + 1, maxNavigationY - minNavigationY + 1)	}		/*	 * Creates the oxygen bar in the lower part of the scene	 */	func createOxygenBar() {		var oxygenWidth = (frame.maxX - frame.minX) * 0.70		var rect = CGRectMake((frame.maxX - frame.minX - oxygenWidth) / 2, frame.minY + 10, oxygenWidth, 15)				let oxygenRectangle = SKShapeNode()		oxygenRectangle.path = CGPathCreateWithRect(rect, nil)		oxygenRectangle.fillColor = UIColor.whiteColor()		addChild(oxygenRectangle)			oxygenUsed = SKShapeNode()		updateOxygenBar()		addChild(oxygenUsed)				let label = SKLabelNode(fontNamed: "Arial-BoldMT")		label.text = "OxigÃªnio"		label.fontSize = 12		label.position = CGPointMake(frame.minX + 50, frame.minY + 12)		addChild(label)	}		/*	 * Creates the submarine	 */	func createSubmarine() {		let posSubmarineX = navigationArea.minX + (navigationArea.maxX - navigationArea.minX) / 2		let posSubmarineY = navigationArea.minY + (navigationArea.maxY - navigationArea.minY) / 2			submarine.position = CGPointMake(posSubmarineX, posSubmarineY)		submarine.anchorPoint = CGPointMake(0.5, 0.5)		addChild(submarine)			submarine.physicsBody = SKPhysicsBody(rectangleOfSize: submarine.size)		submarine.physicsBody?.dynamic = false		submarine.physicsBody?.categoryBitMask = PhysicsCategory.Submarine		submarine.physicsBody?.contactTestBitMask = PhysicsCategory.Shark | PhysicsCategory.Diver		submarine.physicsBody?.collisionBitMask = PhysicsCategory.None	}	/*	 * Creates all sharks and their respective divers	 */	func createSharksAndDivers() {		for i in 0...3 {			let shark = createShark(i)			sharks += [shark]			let diver = createDiver(i)			divers += [diver]			resetSharkAndDiver(shark, diver: diver)		}	}		/*	 * Creates an animated shark	 */	func createShark(index: Int) -> SKSpriteNode {		let shark = SKSpriteNode(imageNamed: "shark1")        shark.position = CGPointMake(-100, navigationArea.minY + CGFloat(index * 45) - shark.size.height / 2)        shark.anchorPoint = CGPointMake(0.5, 0.5)        addChild(shark)	        shark.physicsBody = SKPhysicsBody(rectangleOfSize: shark.size)        shark.physicsBody?.dynamic = true        shark.physicsBody?.categoryBitMask = PhysicsCategory.Shark        shark.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        shark.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animateWithTextures([			SKTexture(imageNamed: "shark1"),			SKTexture(imageNamed: "shark2")], timePerFrame: 0.2)                var sharkAnimation = SKAction.repeatActionForever(animationTexture)        shark.runAction(sharkAnimation)		return shark;	}		/*	 * Creates an animated diver	 */    func createDiver(index: Int) -> SKSpriteNode{        let diver = SKSpriteNode(imageNamed: "diver1")        diver.position = CGPointMake(-100, navigationArea.minY + 5 + CGFloat(index * 45) - diver.size.height / 2)        diver.anchorPoint = CGPointMake(0.5, 0.5)        addChild(diver)	        diver.physicsBody = SKPhysicsBody(rectangleOfSize: diver.size)        diver.physicsBody?.dynamic = true        diver.physicsBody?.categoryBitMask = PhysicsCategory.Diver        diver.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        diver.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animateWithTextures([			SKTexture(imageNamed: "diver1"),			SKTexture(imageNamed: "diver2"),			SKTexture(imageNamed: "diver3")], timePerFrame: 0.2)                var diverAnimation = SKAction.repeatActionForever(animationTexture)        diver.runAction(diverAnimation)				return diver;    }		/*	 * Creates the status bar for the game	 */	func createStatusBar() {        var hud = SKSpriteNode(texture: nil, size: CGSizeMake(self.size.width, self.size.height*0.05))        hud.anchorPoint=CGPointMake(0, 0)        hud.position = CGPointMake(0, self.size.height-hud.size.height)        self.addChild(hud)                let lifeSize = CGSizeMake(hud.size.height-10, hud.size.height-10)		        for i in 1...remainingLifes {            var lifeNode = SKSpriteNode(imageNamed: "submarine")			lifeNode.anchorPoint = CGPointMake(0.5, 0.5)            lifeNode.size = lifeSize            lifeNode.position=CGPointMake(lifeNode.size.width * 1.3 * CGFloat(i), (hud.size.height - 5) / 2)            hud.addChild(lifeNode)            lifeNodes += [lifeNode]        }        		self.scoreNode.position = CGPointMake(hud.size.width * 0.9, 1)        self.scoreNode.text = "0"        self.scoreNode.fontSize = hud.size.height		self.scoreNode.fontName = "Arial Bold"        hud.addChild(self.scoreNode)    }		/*	 * Detects a contact between two sprites	 */    func didBeginContact(contact: SKPhysicsContact) {		if (gamePaused) {			return		}                if (contact.bodyA.categoryBitMask == PhysicsCategory.Submarine && contact.bodyB.categoryBitMask == PhysicsCategory.Shark) {			die()        }        else if (contact.bodyA.categoryBitMask == PhysicsCategory.Shark && contact.bodyB.categoryBitMask == PhysicsCategory.Submarine) {			die()        }		else if (contact.bodyA.categoryBitMask == PhysicsCategory.Submarine && contact.bodyB.categoryBitMask == PhysicsCategory.Diver) {			captureDiver(contact.bodyB.node!)        }		else if (contact.bodyA.categoryBitMask == PhysicsCategory.Diver && contact.bodyB.categoryBitMask == PhysicsCategory.Submarine) {			captureDiver(contact.bodyA.node!)        }    }	/*	 * Captures a diver and increase score	 */	func captureDiver(diver: SKNode) {		if (diver.alpha > 0.0) {			score++			self.scoreNode.text = String(score)			diver.alpha = CGFloat(0.0)			runAction(SKAction.playSoundFileNamed("button-09.wav", waitForCompletion: false))		}	}    	/*	 * Returns a nniform [0, 1] number	 */    func random() -> Float {        return Float(arc4random()) / Float(UINT32_MAX)    }		/*	 * Reset the position of a shark/diver pair after they completed a run through the screen	 */    func resetSharkAndDiver(shark: SKSpriteNode, diver: SKSpriteNode) {		shark.removeActionForKey("run")		diver.removeActionForKey("run")	        var distanceToShark = 5 + random() * 10		diver.alpha = CGFloat(+1.0)                if (random() > 0.5) {			prepareSharkAndDiverFromLeft(shark, diver: diver, distanceToShark: distanceToShark)		} else {			prepareSharkAndDiverFromRight(shark, diver: diver, distanceToShark: distanceToShark)        }    }		/*	 * Reset the position of a shark/diver pair moving left-to-right	 */	func prepareSharkAndDiverFromLeft(shark: SKSpriteNode, diver: SKSpriteNode, distanceToShark: Float) {		shark.xScale = CGFloat(+1.0)		shark.position = CGPointMake(-diver.size.width-shark.size.width-CGFloat(distanceToShark), shark.position.y)		let sharkMove = SKAction.moveTo(CGPoint(x: navigationArea.maxX + 50, y: shark.position.y), duration: 8)				diver.xScale = CGFloat(+1.0)		diver.position = CGPointMake(-diver.size.width, diver.position.y)		let diverMove = SKAction.moveTo(CGPoint(x: navigationArea.maxX + 50 + shark.size.width + CGFloat(distanceToShark), y: diver.position.y), duration: 8)                var interval = CFTimeInterval(random() * 5)        let diverWait = SKAction.waitForDuration(interval)                diver.runAction(diverWait, completion: {			shark.runAction(SKAction.sequence([sharkMove, SKAction.runBlock { self.resetSharkAndDiver(shark, diver: diver) }]), withKey: "run")			diver.runAction(diverMove, withKey: "run")        })	}		/*	 * Reset the position of a shark/diver pair moving right-to-left	 */	func prepareSharkAndDiverFromRight(shark: SKSpriteNode, diver: SKSpriteNode, distanceToShark: Float) {		shark.xScale = CGFloat(-1.0)		shark.position = CGPointMake(navigationArea.maxX + submarine.size.width + diver.size.width + CGFloat(distanceToShark) + 20, diver.position.y)		let sharkMove = SKAction.moveTo(CGPoint(x: navigationArea.minX - 50, y: shark.position.y), duration: 8)				diver.xScale = CGFloat(-1.0)		diver.position = CGPointMake(navigationArea.maxX + submarine.size.width + 20, diver.position.y)		let diverMove = SKAction.moveTo(CGPoint(x: navigationArea.minX - 50 - diver.size.width - CGFloat(distanceToShark), y: diver.position.y), duration: 8)                var interval = CFTimeInterval(random() * 5)        let diverWait = SKAction.waitForDuration(interval)                diver.runAction(diverWait, completion: {			shark.runAction(sharkMove, withKey: "run")			diver.runAction(SKAction.sequence([diverMove, SKAction.runBlock { self.resetSharkAndDiver(shark, diver: diver) }]), withKey: "run")        })	}    	/*	 * Detects the event that triggers moving the submarine	 */	override func touchesEnded(touches: NSSet, withEvent event: UIEvent) {		if (!gamePaused) {			var touch = touches.anyObject() as UITouch!			let location = touch.locationInNode(self)			moveSubmarine(location)		}    }		/*	 * Moves the submarine to a given point in the screen	 */	func moveSubmarine(location: CGPoint) {		var newX = min(max(navigationArea.minX, location.x), navigationArea.maxX)		var newY = min(max(navigationArea.minY, location.y), navigationArea.maxY)		let actionMove = SKAction.moveTo(CGPointMake(newX, newY), duration: 0.5)		submarine.xScale = CGFloat(location.x < submarine.position.x ? -1.0 : 1.0)		submarine.removeAllActions()		submarine.runAction(actionMove)	}		/*	 * Updates oxygen on each frame	 */    override func update(currentTime: NSTimeInterval) {		if (!gamePaused) {			updateOxygen()		}	}		/*	 * Decreases or increases the oxygen tank according to submarine position	 */	func updateOxygen() {        if submarine.position.y >= navigationArea.maxY	{			oxygen = min(oxygen+1, 100)		}        else {			oxygen -= 0.1			if (oxygen < 0) { die(); oxygen = 0.0 }        }        		updateOxygenBar()	}		/*	 * Draws the oxygen bar according to current oxygen	 */	func updateOxygenBar() {		let minX = CGRectGetMinX(frame)        let maxX = CGRectGetMaxX(frame)        let minY = CGRectGetMinY(frame)			var oxygenWidth = (maxX - minX) * 0.70		var rectUsed = CGRectMake((maxX - minX - oxygenWidth) / 2, minY+10, oxygenWidth * CGFloat(oxygen / 100.0), 15)		oxygenUsed.path = CGPathCreateWithRect(rectUsed, nil)        oxygenUsed.fillColor = (oxygen > 20) ? UIColor.greenColor() : UIColor.redColor()	}    	/*	 * Kills the current submarine	 */    func die() {		self.gamePaused = true		runAction(SKAction.playSoundFileNamed("button-10.wav", waitForCompletion: true))		submarine.removeAllActions()				if self.remainingLifes > 0 {			self.lifeNodes[remainingLifes-1].alpha = 0.0			self.remainingLifes--;		}					if (self.remainingLifes == 0) {			showGameOver()			return		}					submarine.runAction(SKAction.fadeOutWithDuration(1), completion: {			self.prepareNewLife()						self.submarine.runAction(SKAction.fadeInWithDuration(1), completion: {				self.gamePaused = false			})		})    }		/*	 * Prepares a new life for the submarine	 */	func prepareNewLife() {		self.submarine.position = CGPointMake(self.size.width/2, self.size.height/2)		self.oxygen = 100				for i in 0...3 {			self.resetSharkAndDiver(sharks[i], diver: divers[i])		}	}		/*	 * Shows the game over dialog	 */	func showGameOver() {		self.gamePaused = true		submarine.runAction(SKAction.fadeOutWithDuration(1))				var alert = UIAlertController(title: "Game Over", message: "", preferredStyle: UIAlertControllerStyle.Alert)		alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default) { _ in							self.remainingLifes=3			for lifeNode in self.lifeNodes {				lifeNode.alpha = 1.0			}						self.score = 0			self.scoreNode.text = String(0)			self.submarine.alpha = 1.0			self.prepareNewLife()			self.gamePaused = false		})					self.view?.window?.rootViewController?.presentViewController(alert, animated: true, completion: nil)	}}