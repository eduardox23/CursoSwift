////  PlayScene.swift//  Seaquest////  Created by Marcio Barros on 11/26/14.//  Copyright (c) 2014 UNIRIO. All rights reserved.//import SpriteKitimport AVFoundation struct PhysicsCategory {    static let None      : UInt32 = 0    static let Submarine : UInt32 = 0b001    static let Diver     : UInt32 = 0b010    static let Shark     : UInt32 = 0b100}class PlayScene: SKScene, SKPhysicsContactDelegate {	let azymuth = SKSpriteNode(imageNamed: "azymuth")	let seaFloor = SKSpriteNode(imageNamed: "seafloor")    let submarine = SKSpriteNode(imageNamed: "submarine")	var navigationArea : Region!    var oxygen = 100.0    var oxygenUsed = SKShapeNode()    var sharks : [SKSpriteNode] = []	var divers : [SKSpriteNode] = []	var lifeNodes : [SKSpriteNode] = []    var remainingLifes = 3    var scoreNode = SKLabelNode()    var score = 0	var gamePaused = false	    override func didMoveToView(view: SKView) {		physicsWorld.gravity = CGVectorMake(0, 0)		physicsWorld.contactDelegate = self			createBackground()		createOxygenBar()		createSubmarine()		createSharks()		createHUD()    }		func createBackground() {		backgroundColor = UIColor(hex: 0x0000FF)			let minX = CGRectGetMinX(frame)		let minY = CGRectGetMinY(frame)		let maxY = CGRectGetMaxY(frame)			//let azymuth = SKSpriteNode(imageNamed: "azymuth")		azymuth.anchorPoint = CGPointMake(0.0, 1.0)		azymuth.position = CGPointMake(minX, maxY - 40)		addChild(azymuth);				//let seaFloor = SKSpriteNode(imageNamed: "seafloor")		seaFloor.anchorPoint = CGPointMake(0.0, 1.0)		seaFloor.position = CGPointMake(minX, minY + seaFloor.size.height + 30)		addChild(seaFloor);	}		func createOxygenBar() {		let minX = CGRectGetMinX(frame)		let maxX = CGRectGetMaxX(frame)		let minY = CGRectGetMinY(frame)				var oxygenWidth = (maxX - minX) * 0.70		var rect = CGRectMake((maxX - minX - oxygenWidth) / 2, minY+10, oxygenWidth, 15)				let oxygenRectangle = SKShapeNode()		oxygenRectangle.path = CGPathCreateWithRect(rect, nil)		oxygenRectangle.fillColor = UIColor.whiteColor()		addChild(oxygenRectangle)			updateOxygen()		addChild(oxygenUsed)				let label = SKLabelNode(fontNamed: "Arial-BoldMT")		label.text = "OxigÃªnio"		label.fontSize = 12		label.position = CGPointMake(minX + 50, minY + 12)		addChild(label)	}		func createSubmarine() {		let minX = CGRectGetMinX(frame)		let maxX = CGRectGetMaxX(frame)		let minY = CGRectGetMinY(frame)		let maxY = CGRectGetMaxY(frame)			let minSubmarineY = minY + seaFloor.size.height + 40 + submarine.size.height / 2		let maxSubmarineY = maxY - azymuth.size.height - 50 + submarine.size.height / 2		let minSubmarineX = minX + 10 + submarine.size.width / 2		let maxSubmarineX = maxX - 10 - submarine.size.width / 2				navigationArea = Region(minX: minSubmarineX, minY: minSubmarineY, maxX: maxSubmarineX, maxY: maxSubmarineY)				let posSubmarineX = minSubmarineY + (maxSubmarineX - minSubmarineX) / 2		let posSubmarineY = minSubmarineY + (maxSubmarineY - minSubmarineY) / 2				submarine.position = CGPointMake(posSubmarineX, posSubmarineY)		submarine.anchorPoint = CGPointMake(0.5, 0.5)		addChild(submarine)			submarine.physicsBody = SKPhysicsBody(rectangleOfSize: submarine.size)		submarine.physicsBody?.dynamic = false		submarine.physicsBody?.categoryBitMask = PhysicsCategory.Submarine		submarine.physicsBody?.contactTestBitMask = PhysicsCategory.Shark | PhysicsCategory.Diver		submarine.physicsBody?.collisionBitMask = PhysicsCategory.None	}		func createSharks() {		for i in 0...3 {			sharks += [createShark(i)]			divers += [createDiver(i)]			resetShark(i)		}	}		func createHUD() {		        // Create a root node to group the HUD elemets        var hud = SKSpriteNode(texture: nil, size: CGSizeMake(self.size.width, self.size.height*0.05))        hud.anchorPoint=CGPointMake(0, 0)        hud.position = CGPointMake(0, self.size.height-hud.size.height)        self.addChild(hud)                // Display the remaining lifes        let lifeSize = CGSizeMake(hud.size.height-10, hud.size.height-10)		        for i in 1...remainingLifes {            var lifeNode = SKSpriteNode(imageNamed: "submarine")			lifeNode.anchorPoint = CGPointMake(0.5, 0.5)            lifeNode.size = lifeSize            lifeNode.position=CGPointMake(lifeNode.size.width * 1.3 * CGFloat(i), (hud.size.height - 5) / 2)            hud.addChild(lifeNode)            lifeNodes += [lifeNode]        }                // Display the current score		self.scoreNode.position = CGPointMake(hud.size.width-hud.size.width * 0.1, 1)        self.scoreNode.text = "0"        self.scoreNode.fontSize = hud.size.height		self.scoreNode.fontName = "Arial Bold"        hud.addChild(self.scoreNode)            }		func createShark(index: Int) -> SKSpriteNode {		let shark = SKSpriteNode(imageNamed: "shark1")        shark.position = CGPointMake(-100, navigationArea.minY + CGFloat(index * 45))        shark.anchorPoint = CGPointMake(0.0, 1.0)        addChild(shark)	        shark.physicsBody = SKPhysicsBody(rectangleOfSize: shark.size)        shark.physicsBody?.dynamic = true        shark.physicsBody?.categoryBitMask = PhysicsCategory.Shark        shark.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        shark.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animateWithTextures([			SKTexture(imageNamed: "shark1"),			SKTexture(imageNamed: "shark2")], timePerFrame: 0.2)                var sharkAnimation = SKAction.repeatActionForever(animationTexture)        shark.runAction(sharkAnimation)		return shark;	}	    func createDiver(index: Int) -> SKSpriteNode{        let diver = SKSpriteNode(imageNamed: "diver1")        diver.position = CGPointMake(-100, navigationArea.minY + 5 + CGFloat(index * 45))        diver.anchorPoint = CGPointMake(0.0, 1.0)        addChild(diver)	        diver.physicsBody = SKPhysicsBody(rectangleOfSize: diver.size)        diver.physicsBody?.dynamic = true        diver.physicsBody?.categoryBitMask = PhysicsCategory.Diver        diver.physicsBody?.contactTestBitMask = PhysicsCategory.Submarine        diver.physicsBody?.collisionBitMask = PhysicsCategory.None	        let animationTexture = SKAction.animateWithTextures([			SKTexture(imageNamed: "diver1"),			SKTexture(imageNamed: "diver2"),			SKTexture(imageNamed: "diver3")], timePerFrame: 0.2)                var diverAnimation = SKAction.repeatActionForever(animationTexture)        diver.runAction(diverAnimation)				return diver;    }        func didBeginContact(contact: SKPhysicsContact) {		if (gamePaused) {			return		}                var firstBody: SKPhysicsBody        var secondBody: SKPhysicsBody                if contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask {			firstBody = contact.bodyA			secondBody = contact.bodyB		} else {			firstBody = contact.bodyB			secondBody = contact.bodyA        }                if ((firstBody.categoryBitMask & PhysicsCategory.Submarine != 0) && (secondBody.categoryBitMask & PhysicsCategory.Shark != 0)) {			die()        }                if ((firstBody.categoryBitMask & PhysicsCategory.Submarine != 0) && (secondBody.categoryBitMask & PhysicsCategory.Diver != 0)) {			if (secondBody.node?.xScale != 0.0) {				score++				self.scoreNode.text = String(score)				secondBody.node?.xScale = CGFloat(0.0)				runAction(SKAction.playSoundFileNamed("button-09.wav", waitForCompletion: true))			}        }    }        func random() -> Float {        return Float(arc4random()) / Float(UINT32_MAX)    }			    func resetShark(index: Int) {        var distanceToShark = 5 + random() * 10					var diver = divers[index]		var shark = sharks[index]		        var sharkMove : SKAction!        var diverMove : SKAction!                if (random() > 0.5) {			diver.xScale = CGFloat(+1.0)			shark.xScale = CGFloat(+1.0)			shark.position = CGPointMake(-diver.size.width-shark.size.width-CGFloat(distanceToShark), navigationArea.minY + CGFloat(index * 45))						sharkMove = SKAction.moveTo(			CGPoint(x: navigationArea.maxX + 50, y: shark.position.y),			duration: 8)						diver.position = CGPointMake(-diver.size.width, navigationArea.minY + 5 + CGFloat(index * 45))						diverMove = SKAction.moveTo(				CGPoint(x: navigationArea.maxX + 50 + shark.size.width + CGFloat(distanceToShark), y: diver.position.y),				duration: 8)		} else {			diver.xScale = CGFloat(-1.0)			shark.xScale = CGFloat(-1.0)			shark.position = CGPointMake(navigationArea.maxX + submarine.size.width + diver.size.width + CGFloat(distanceToShark) + 20, navigationArea.minY + CGFloat(index * 45))						sharkMove = SKAction.moveTo(			CGPoint(x: navigationArea.minX - 50, y: shark.position.y),			duration: 8)						diver.position = CGPointMake(navigationArea.maxX + submarine.size.width + 20, navigationArea.minY + 5 + CGFloat(index * 45))						diverMove = SKAction.moveTo(			CGPoint(x: navigationArea.minX - 50 - diver.size.width - CGFloat(distanceToShark), y: diver.position.y),			duration: 8)			        }                var interval = CFTimeInterval(random() * 5)        let diverWait = SKAction.waitForDuration(interval)                diver.runAction(diverWait, completion: {			shark.runAction(sharkMove,				withKey: "run")				diver.runAction(SKAction.sequence([diverMove, SKAction.waitForDuration(1.0), SKAction.runBlock { self.resetShark(index) }]),				withKey: "run")        })    }    	override func touchesEnded(touches: NSSet, withEvent event: UIEvent) {		var touch = touches.anyObject() as UITouch!		let location = touch.locationInNode(self)		moveSubmarine(location)    }		func moveSubmarine(location: CGPoint) {		if (!gamePaused) {			var newX = min(max(navigationArea.minX, location.x), navigationArea.maxX)			var newY = min(max(navigationArea.minY, location.y), navigationArea.maxY)			let actionMove = SKAction.moveTo(CGPointMake(newX, newY), duration: 0.5)			submarine.removeAllActions()			submarine.runAction(actionMove)			submarine.xScale = CGFloat(location.x < submarine.position.x ? -1.0 : 1.0)		}	}	    override func update(currentTime: NSTimeInterval) {		if (gamePaused) {			return		}	        if submarine.position.y >= navigationArea.maxY	{			oxygen = min(oxygen+1, 100)		}        else {			oxygen -= 0.1			if (oxygen < 0) { die(); oxygen = 0.0 }        }        		updateOxygen()	}		func updateOxygen() {		let minX = CGRectGetMinX(frame)        let maxX = CGRectGetMaxX(frame)        let minY = CGRectGetMinY(frame)			var oxygenWidth = (maxX - minX) * 0.70		var rectUsed = CGRectMake((maxX - minX - oxygenWidth) / 2, minY+10, oxygenWidth * CGFloat(oxygen / 100.0), 15)		oxygenUsed.path = CGPathCreateWithRect(rectUsed, nil)        oxygenUsed.fillColor = (oxygen > 20) ? UIColor.greenColor() : UIColor.redColor()	}        func die() {		self.gamePaused = true		runAction(SKAction.playSoundFileNamed("button-10.wav", waitForCompletion: true))			submarine.removeAllActions()		for i in 0...3 {			self.sharks[i].removeActionForKey("run")			self.divers[i].removeActionForKey("run")		}				// remove one life from hud		if self.remainingLifes > 0 {			self.lifeNodes[remainingLifes-1].alpha = 0.0			self.remainingLifes--;		}					// check if remaining lifes exists		if (self.remainingLifes==0) {			showGameOverAlert()			return		}					// Stop movement, fade out, move to center, fade in		submarine.runAction(SKAction.fadeOutWithDuration(1) , completion: {			self.restartGame()						self.submarine.runAction(SKAction.fadeInWithDuration(1), completion: {				self.gamePaused = false			})		})    }		func restartGame() {		self.submarine.position = CGPointMake(self.size.width/2, self.size.height/2)		self.oxygen = 100				for i in 0...3 {			self.resetShark(i)		}	}		func showGameOverAlert() {		self.gamePaused = true		var alert = UIAlertController(title: "Game Over", message: "", preferredStyle: UIAlertControllerStyle.Alert)		alert.addAction(UIAlertAction(title: "OK", style: UIAlertActionStyle.Default)  { _ in							// restore lifes in HUD			self.remainingLifes=3			for(var i = 0; i<3; i++) {				self.lifeNodes[i].alpha=1.0			}			self.restartGame()			// reset score			self.score = 0			self.scoreNode.text = String(0)			self.gamePaused = false		})					// show alert		self.view?.window?.rootViewController?.presentViewController(alert, animated: true, completion: nil)	}}